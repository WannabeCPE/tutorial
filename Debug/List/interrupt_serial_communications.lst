###############################################################################
#
# IAR C/C++ Compiler V7.20.1.997/W32 for MSP430           15/Dec/2020  17:38:31
# Copyright 1996-2020 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.20
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\19196\OneDrive\Documents\ECE 306
#        current\Project_10\interrupt_serial_communications.c
#    Command line  =  
#        -f C:\Users\19196\AppData\Local\Temp\EW1F9F.tmp
#        ("C:\Users\19196\OneDrive\Documents\ECE 306
#        current\Project_10\interrupt_serial_communications.c" -lC
#        "C:\Users\19196\OneDrive\Documents\ECE 306
#        current\Project_10\Debug\List" -o
#        "C:\Users\19196\OneDrive\Documents\ECE 306
#        current\Project_10\Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --debug -D__MSP430FR2355__ -e --double=32
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\430\lib\dlib\dl430xlsfn.h" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.4\430\" --core=430X --data_model=small
#        -On --multiplier=32 --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\19196\OneDrive\Documents\ECE 306
#        current\Project_10\Debug\List\interrupt_serial_communications.lst
#    Object file   =  
#        C:\Users\19196\OneDrive\Documents\ECE 306
#        current\Project_10\Debug\Obj\interrupt_serial_communications.r43
#
###############################################################################

C:\Users\19196\OneDrive\Documents\ECE 306 current\Project_10\interrupt_serial_communications.c
      1          //------------------------------------------------------------------------------
      2          //
      3          //  Description: This file contains the Interrupt Service Routines for Serial Communications
      4          //
      5          //
      6          //  Cody Lane
      7          //  October 2020
      8          //  Built with IAR Embedded Workbench Version: V7.20.1 
      9          //------------------------------------------------------------------------------
     10          
     11          #include  "msp430.h"

   \                                 In  segment DATA16_AN, at 0x50c
   \   union <unnamed> _A_UCA0RXBUF_L
   \                     _A_UCA0RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x50e
   \   union <unnamed> _A_UCA0TXBUF_L
   \                     _A_UCA0TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51a
   \   union <unnamed> _A_UCA0IE_L
   \                     _A_UCA0IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51e
   \   union <unnamed> _A_UCA0IV_L
   \                     _A_UCA0IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x58c
   \   union <unnamed> _A_UCA1RXBUF_L
   \                     _A_UCA1RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x58e
   \   union <unnamed> _A_UCA1TXBUF_L
   \                     _A_UCA1TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x59a
   \   union <unnamed> _A_UCA1IE_L
   \                     _A_UCA1IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x59e
   \   union <unnamed> _A_UCA1IV_L
   \                     _A_UCA1IV_L:
   \   000000                DS8 2
     12          #include  "functions.h"
     13          #include <string.h>
     14          #include  "macros.h"
     15          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          volatile char CARROT_COMMAND[SMALL_RING_SIZE];
   \                     CARROT_COMMAND:
   \   000000                DS8 16

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     17          volatile char FRAM_2_IOT[LARGE_RING_SIZE];
   \                     FRAM_2_IOT:
   \   000000                DS8 32

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          unsigned int carrot_wr = RESET_STATE;
   \                     carrot_wr:
   \   000000                DS8 2
     19          extern volatile unsigned int fram_2_iot_ready;

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     20          unsigned int fram_direct_iot = RESET_STATE;
   \                     fram_direct_iot:
   \   000000                DS8 2
     21          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     22          volatile char IOT_COMMAND[5][10];
   \                     IOT_COMMAND:
   \   000000                DS8 50

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     23          volatile unsigned int iot_command_direct = RESET_STATE;
   \                     iot_command_direct:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     24          unsigned int iot_command_wr = RESET_STATE;
   \                     iot_command_wr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     25          volatile char iot_command_received = RESET_STATE;
   \                     iot_command_received:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     26          char iot_command_capture = RESET_STATE;
   \                     iot_command_capture:
   \   000000                DS8 1
     27          
     28          extern volatile unsigned int send_at; 
     29          extern volatile unsigned int get_ok;

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     30          volatile unsigned int ok_received = RESET_STATE;
   \                     ok_received:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     31          unsigned int S_count = RESET_STATE;
   \                     S_count:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     32          unsigned int ok_find_end = RESET_STATE;
   \                     ok_find_end:
   \   000000                DS8 2
     33          
     34          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     35          char IP_address[SMALL_RING_SIZE+1];
   \                     IP_address:
   \   000000                DS8 17

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     36          unsigned int ip_wr = RESET_STATE;
   \                     ip_wr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     37          volatile unsigned int IP_get = RESET_STATE;
   \                     IP_get:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     38          unsigned int IP_look = RESET_STATE;
   \                     IP_look:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     39          unsigned int IP_capture = RESET_STATE;
   \                     IP_capture:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     40          volatile unsigned int IP_received = RESET_STATE;
   \                     IP_received:
   \   000000                DS8 2
     41          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     42          char SSID[11];
   \                     SSID:
   \   000000                DS8 11

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     43          unsigned int ssid_wr = RESET_STATE;
   \                     ssid_wr:
   \   000000                DS8 2
     44          extern volatile unsigned int get_SSID;

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     45          unsigned int quote_count = RESET_STATE;
   \                     quote_count:
   \   000000                DS8 2
     46          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     47          volatile char SSID_received = RESET_STATE;
   \                     SSID_received:
   \   000000                DS8 1
     48          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     49          unsigned int unique_id_count = RESET_STATE;
   \                     unique_id_count:
   \   000000                DS8 2
     50          
     51          
     52          extern volatile unsigned int usb_rx_ring_wr;
     53          extern volatile unsigned int usb_rx_ring_rd;
     54          extern volatile unsigned int iot_rx_ring_wr;
     55          extern volatile unsigned int iot_rx_ring_rd;
     56          extern volatile char USB_Char_Rx[SMALL_RING_SIZE];
     57          extern volatile char IOT_Char_Rx[SMALL_RING_SIZE];
     58          extern volatile char usb_process_buff[LARGE_RING_SIZE];
     59          extern volatile char iot_process_buff[LARGE_RING_SIZE];
     60          
     61          extern volatile unsigned int usb_pb_index;
     62          extern volatile unsigned int iot_pb_index;
     63          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     64          volatile unsigned int iot_fram_command = RESET_STATE;
   \                     iot_fram_command:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     65          volatile unsigned int iot_fram_command_received = RESET_STATE;
   \                     iot_fram_command_received:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     66          volatile unsigned int pc_fram_command = RESET_STATE;
   \                     pc_fram_command:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     67          volatile unsigned int pc_fram_command_received = RESET_STATE;
   \                     pc_fram_command_received:
   \   000000                DS8 2
     68          
     69          extern volatile unsigned int iot_char_received;
     70          extern volatile unsigned int pc_char_received;
     71          
     72          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     73          volatile unsigned int iot_2_pc_transmit = RESET_STATE;
   \                     iot_2_pc_transmit:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     74          volatile unsigned int pc_2_iot_transmit = RESET_STATE;
   \                     pc_2_iot_transmit:
   \   000000                DS8 2
     75          
     76          extern volatile char speed;
     77          extern volatile unsigned int change_baud;
     78          
     79          
     80          extern volatile char display_state;
     81          
     82          //------------------------------------------------------------------------------
     83          #pragma vector=EUSCI_A0_VECTOR

   \                                 In  segment ISR_CODE, align 2
     84          __interrupt void eUSCI_A0_ISR(void) {
   \                     eUSCI_A0_ISR:
   \   000000   5F15         PUSHM.W #0x6, R15
     85          	unsigned int temp;
     86          	unsigned int temp_2;
     87          	unsigned int temp_3;
     88          	switch (__even_in_range(UCA0IV, 0x08)) {
   \   000002   1F421E05     MOV.W   &0x51e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for eUSCI_A0_ISR>_0`:
   \   000008   423D         JMP     ??eUSCI_A0_ISR_11
   \   00000A   033C         JMP     ??eUSCI_A0_ISR_40
   \   00000C   0B3D         JMP     ??eUSCI_A0_ISR_41
   \   00000E   3F3D         JMP     ??eUSCI_A0_ISR_11
   \   000010   3E3D         JMP     ??eUSCI_A0_ISR_11
     89          	case 0: // Vector 0 - no interrupt
     90          		break;
     91          	case 2: // Vector 2 - RXIFG
     92          		temp = iot_rx_ring_wr;
   \                     ??eUSCI_A0_ISR_40:
   \   000012   1D42....     MOV.W   &iot_rx_ring_wr, R13
     93          		IOT_Char_Rx[temp] = UCA0RXBUF;
   \   000016   1E420C05     MOV.W   &0x50c, R14
   \   00001A   CD4E....     MOV.B   R14, IOT_Char_Rx(R13)
     94          
     95          
     96          		if (IP_get) {
   \   00001E   8293....     CMP.W   #0x0, &IP_get
   \   000022   4124         JEQ     ??eUSCI_A0_ISR_15
     97          			if (IOT_Char_Rx[temp] == 'y') {
   \   000024   FD907900.... CMP.B   #0x79, IOT_Char_Rx(R13)
   \   00002A   0220         JNE     ??eUSCI_A0_ISR_16
     98          				IP_look = TRUE;
   \   00002C   9243....     MOV.W   #0x1, &IP_look
     99          			}
    100          			if (IP_look) {
   \                     ??eUSCI_A0_ISR_16:
   \   000030   8293....     CMP.W   #0x0, &IP_look
   \   000034   0C24         JEQ     ??eUSCI_A0_ISR_17
    101          				if ((IOT_Char_Rx[temp] >= 0x30) && (IOT_Char_Rx[temp] <= 0x39)) {
   \   000036   FD903000.... CMP.B   #0x30, IOT_Char_Rx(R13)
   \   00003C   0828         JNC     ??eUSCI_A0_ISR_17
   \   00003E   FD903A00.... CMP.B   #0x3a, IOT_Char_Rx(R13)
   \   000044   042C         JC      ??eUSCI_A0_ISR_17
    102          					IP_capture = TRUE;
   \   000046   9243....     MOV.W   #0x1, &IP_capture
    103          					IP_look = FALSE;
   \   00004A   8243....     MOV.W   #0x0, &IP_look
    104          				}
    105          			}
    106          			if (IP_capture) {
   \                     ??eUSCI_A0_ISR_17:
   \   00004E   8293....     CMP.W   #0x0, &IP_capture
   \   000052   1024         JEQ     ??eUSCI_A0_ISR_12
    107          				if (IOT_Char_Rx[temp] == ':') {
   \   000054   FD903A00.... CMP.B   #0x3a, IOT_Char_Rx(R13)
   \   00005A   0520         JNE     ??eUSCI_A0_ISR_18
    108          					IP_capture = FALSE;
   \   00005C   8243....     MOV.W   #0x0, &IP_capture
    109          					IP_received = TRUE;
   \   000060   9243....     MOV.W   #0x1, &IP_received
   \   000064   073C         JMP     ??eUSCI_A0_ISR_12
    110          
    111          				}
    112          				else {
    113          					IP_address[ip_wr++] = IOT_Char_Rx[temp];
   \                     ??eUSCI_A0_ISR_18:
   \   000066   1F42....     MOV.W   &ip_wr, R15
   \   00006A   DF4D........ MOV.B   IOT_Char_Rx(R13), IP_address(R15)
   \   000070   9253....     ADD.W   #0x1, &ip_wr
    114          				}
    115          			}
    116          			if (IP_received) {
   \                     ??eUSCI_A0_ISR_12:
   \   000074   8293....     CMP.W   #0x0, &IP_received
   \   000078   1624         JEQ     ??eUSCI_A0_ISR_15
    117          				if (IOT_Char_Rx[temp] == 'S') {
   \   00007A   FD905300.... CMP.B   #0x53, IOT_Char_Rx(R13)
   \   000080   0220         JNE     ??eUSCI_A0_ISR_19
    118          					S_count++;
   \   000082   9253....     ADD.W   #0x1, &S_count
    119          				}
    120          				if ((S_count == 3) && (IOT_Char_Rx[temp] == '\n')) {
   \                     ??eUSCI_A0_ISR_19:
   \   000086   B2900300.... CMP.W   #0x3, &S_count
   \   00008C   0C20         JNE     ??eUSCI_A0_ISR_15
   \   00008E   FD900A00.... CMP.B   #0xa, IOT_Char_Rx(R13)
   \   000094   0820         JNE     ??eUSCI_A0_ISR_15
    121          					IP_received = FALSE;
   \   000096   8243....     MOV.W   #0x0, &IP_received
    122          					IP_get = FALSE;
   \   00009A   8243....     MOV.W   #0x0, &IP_get
    123          					S_count = RESET_STATE;
   \   00009E   8243....     MOV.W   #0x0, &S_count
    124          					send_at = TRUE;
   \   0000A2   9243....     MOV.W   #0x1, &send_at
    125          				}
    126          			}
    127          		}
    128          		if (get_ok) {
   \                     ??eUSCI_A0_ISR_15:
   \   0000A6   8293....     CMP.W   #0x0, &get_ok
   \   0000AA   1324         JEQ     ??eUSCI_A0_ISR_20
    129          			if (IOT_Char_Rx[temp] == 'O') {
   \   0000AC   FD904F00.... CMP.B   #0x4f, IOT_Char_Rx(R13)
   \   0000B2   0220         JNE     ??eUSCI_A0_ISR_21
    130          				ok_find_end = TRUE;
   \   0000B4   9243....     MOV.W   #0x1, &ok_find_end
    131          			}
    132          			if (ok_find_end) {
   \                     ??eUSCI_A0_ISR_21:
   \   0000B8   8293....     CMP.W   #0x0, &ok_find_end
   \   0000BC   0A24         JEQ     ??eUSCI_A0_ISR_20
    133          				if (IOT_Char_Rx[temp] == '\n') {
   \   0000BE   FD900A00.... CMP.B   #0xa, IOT_Char_Rx(R13)
   \   0000C4   0620         JNE     ??eUSCI_A0_ISR_20
    134          					get_ok = FALSE;
   \   0000C6   8243....     MOV.W   #0x0, &get_ok
    135          					ok_find_end = FALSE;
   \   0000CA   8243....     MOV.W   #0x0, &ok_find_end
    136          					ok_received = TRUE;
   \   0000CE   9243....     MOV.W   #0x1, &ok_received
    137          				}
    138          			}
    139          		}
    140          
    141          		if (get_SSID) {
   \                     ??eUSCI_A0_ISR_20:
   \   0000D2   8293....     CMP.W   #0x0, &get_SSID
   \   0000D6   2124         JEQ     ??eUSCI_A0_ISR_13
    142          			if (IOT_Char_Rx[temp] == '"') {
   \   0000D8   FD902200.... CMP.B   #0x22, IOT_Char_Rx(R13)
   \   0000DE   0220         JNE     ??eUSCI_A0_ISR_22
    143          				quote_count++;
   \   0000E0   9253....     ADD.W   #0x1, &quote_count
    144          			}
    145          			if (quote_count == 2) {
   \                     ??eUSCI_A0_ISR_22:
   \   0000E4   A293....     CMP.W   #0x2, &quote_count
   \   0000E8   0A20         JNE     ??eUSCI_A0_ISR_23
    146          				quote_count = RESET_STATE;
   \   0000EA   8243....     MOV.W   #0x0, &quote_count
    147          				get_SSID = FALSE;
   \   0000EE   8243....     MOV.W   #0x0, &get_SSID
    148          				SSID_received = TRUE;
   \   0000F2   D243....     MOV.B   #0x1, &SSID_received
    149          				display_state = IP_SSID_DISPLAY;
   \   0000F6   F2404900.... MOV.B   #0x49, &display_state
   \   0000FC   0E3C         JMP     ??eUSCI_A0_ISR_13
    150          			}
    151          			else if ((quote_count == 1) && (IOT_Char_Rx[temp] != '"')) {
   \                     ??eUSCI_A0_ISR_23:
   \   0000FE   9293....     CMP.W   #0x1, &quote_count
   \   000102   0B20         JNE     ??eUSCI_A0_ISR_13
   \   000104   FD902200.... CMP.B   #0x22, IOT_Char_Rx(R13)
   \   00010A   0724         JEQ     ??eUSCI_A0_ISR_13
    152          				SSID[ssid_wr++] = IOT_Char_Rx[temp];
   \   00010C   1F42....     MOV.W   &ssid_wr, R15
   \   000110   DF4D........ MOV.B   IOT_Char_Rx(R13), SSID(R15)
   \   000116   9253....     ADD.W   #0x1, &ssid_wr
    153          			}
    154          		}
    155          
    156          		if (iot_command_capture) {
   \                     ??eUSCI_A0_ISR_13:
   \   00011A   C293....     CMP.B   #0x0, &iot_command_capture
   \   00011E   1924         JEQ     ??eUSCI_A0_ISR_14
    157          			if (IOT_Char_Rx[temp] == 0x0D) {
   \   000120   FD900D00.... CMP.B   #0xd, IOT_Char_Rx(R13)
   \   000126   0720         JNE     ??eUSCI_A0_ISR_24
    158          				iot_command_capture = FALSE;
   \   000128   C243....     MOV.B   #0x0, &iot_command_capture
    159          				iot_command_wr = RESET_STATE;
   \   00012C   8243....     MOV.W   #0x0, &iot_command_wr
    160          				iot_command_received = TRUE;
   \   000130   D243....     MOV.B   #0x1, &iot_command_received
   \   000134   0E3C         JMP     ??eUSCI_A0_ISR_14
    161          			}
    162          			else {
    163          				temp_3 = iot_command_direct;
   \                     ??eUSCI_A0_ISR_24:
   \   000136   1A42....     MOV.W   &iot_command_direct, R10
    164          				IOT_COMMAND[temp_3][iot_command_wr++] = IOT_Char_Rx[temp];
   \   00013A   0F4A         MOV.W   R10, R15
   \   00013C   0F5F         RLA.W   R15
   \   00013E   0E4F         MOV.W   R15, R14
   \   000140   5F06         RLAM.W  #0x2, R15
   \   000142   0F5E         ADD.W   R14, R15
   \   000144   1F52....     ADD.W   &iot_command_wr, R15
   \   000148   DF4D........ MOV.B   IOT_Char_Rx(R13), IOT_COMMAND(R15)
   \   00014E   9253....     ADD.W   #0x1, &iot_command_wr
    165          			}
    166          		}
    167          		
    168          		if (IOT_Char_Rx[temp] == 0x1B) {
   \                     ??eUSCI_A0_ISR_14:
   \   000152   FD901B00.... CMP.B   #0x1b, IOT_Char_Rx(R13)
   \   000158   0220         JNE     ??eUSCI_A0_ISR_25
    169          			iot_fram_command = TRUE;
   \   00015A   9243....     MOV.W   #0x1, &iot_fram_command
    170          		}
    171          
    172          		if (iot_fram_command) {
   \                     ??eUSCI_A0_ISR_25:
   \   00015E   8293....     CMP.W   #0x0, &iot_fram_command
   \   000162   5324         JEQ     ??eUSCI_A0_ISR_26
    173          			switch (IOT_Char_Rx[temp]) {
   \   000164   5E4D....     MOV.B   IOT_Char_Rx(R13), R14
   \   000168   7E800D00     SUB.B   #0xd, R14
   \   00016C   1724         JEQ     ??eUSCI_A0_ISR_27
   \   00016E   7E800E00     SUB.B   #0xe, R14
   \   000172   4824         JEQ     ??eUSCI_A0_ISR_28
   \   000174   7E801500     SUB.B   #0x15, R14
   \   000178   1C24         JEQ     ??eUSCI_A0_ISR_29
   \   00017A   5E83         SUB.B   #0x1, R14
   \   00017C   2024         JEQ     ??eUSCI_A0_ISR_30
   \   00017E   5E83         SUB.B   #0x1, R14
   \   000180   2B24         JEQ     ??eUSCI_A0_ISR_31
   \   000182   5E83         SUB.B   #0x1, R14
   \   000184   3624         JEQ     ??eUSCI_A0_ISR_32
   \   000186   6E83         SUB.B   #0x2, R14
   \   000188   2024         JEQ     ??eUSCI_A0_ISR_33
   \   00018A   5E83         SUB.B   #0x1, R14
   \   00018C   2B24         JEQ     ??eUSCI_A0_ISR_34
   \   00018E   7E801000     SUB.B   #0x10, R14
   \   000192   7D24         JEQ     ??eUSCI_A0_ISR_11
   \   000194   7E800D00     SUB.B   #0xd, R14
   \   000198   0624         JEQ     ??eUSCI_A0_ISR_35
   \   00019A   793C         JMP     ??eUSCI_A0_ISR_11
    174          			case 0x0D:
    175          				iot_fram_command = FALSE;
   \                     ??eUSCI_A0_ISR_27:
   \   00019C   8243....     MOV.W   #0x0, &iot_fram_command
    176          				// message received variable needed 
    177          				iot_fram_command_received = TRUE;
   \   0001A0   9243....     MOV.W   #0x1, &iot_fram_command_received
    178          				break;
   \   0001A4   743C         JMP     ??eUSCI_A0_ISR_11
    179          			case 'F':
    180          				// do what needed for fast
    181          				break;
    182          			case 'S':
    183          				if (unique_id_count == 1) {
   \                     ??eUSCI_A0_ISR_35:
   \   0001A6   9293....     CMP.W   #0x1, &unique_id_count
   \   0001AA   7120         JNE     ??eUSCI_A0_ISR_11
    184          					unique_id_count++;
   \   0001AC   9253....     ADD.W   #0x1, &unique_id_count
    185          				}
    186          				break;
   \   0001B0   6E3C         JMP     ??eUSCI_A0_ISR_11
    187          			case '0':
    188          				if (unique_id_count == 2) {
   \                     ??eUSCI_A0_ISR_29:
   \   0001B2   A293....     CMP.W   #0x2, &unique_id_count
   \   0001B6   6B20         JNE     ??eUSCI_A0_ISR_11
    189          					unique_id_count++;
   \   0001B8   9253....     ADD.W   #0x1, &unique_id_count
    190          				}
    191          				break;
   \   0001BC   683C         JMP     ??eUSCI_A0_ISR_11
    192          			case '1':
    193          				if (unique_id_count == 2) {
   \                     ??eUSCI_A0_ISR_30:
   \   0001BE   A293....     CMP.W   #0x2, &unique_id_count
   \   0001C2   6520         JNE     ??eUSCI_A0_ISR_11
    194          					unique_id_count++;
   \   0001C4   9253....     ADD.W   #0x1, &unique_id_count
    195          				}
    196          				break;
   \   0001C8   623C         JMP     ??eUSCI_A0_ISR_11
    197          			case '5':
    198          				if (unique_id_count == 3) {
   \                     ??eUSCI_A0_ISR_33:
   \   0001CA   B2900300.... CMP.W   #0x3, &unique_id_count
   \   0001D0   5E20         JNE     ??eUSCI_A0_ISR_11
    199          					unique_id_count++;
   \   0001D2   9253....     ADD.W   #0x1, &unique_id_count
    200          				}
    201          				break;
   \   0001D6   5B3C         JMP     ??eUSCI_A0_ISR_11
    202          			case '2':
    203          				if (unique_id_count == 4) {
   \                     ??eUSCI_A0_ISR_31:
   \   0001D8   A292....     CMP.W   #0x4, &unique_id_count
   \   0001DC   5820         JNE     ??eUSCI_A0_ISR_11
    204          					unique_id_count++;
   \   0001DE   9253....     ADD.W   #0x1, &unique_id_count
    205          				}
    206          				break;
   \   0001E2   553C         JMP     ??eUSCI_A0_ISR_11
    207          			case '6':
    208          				if (unique_id_count == 5) {
   \                     ??eUSCI_A0_ISR_34:
   \   0001E4   B2900500.... CMP.W   #0x5, &unique_id_count
   \   0001EA   5120         JNE     ??eUSCI_A0_ISR_11
    209          					unique_id_count++;
   \   0001EC   9253....     ADD.W   #0x1, &unique_id_count
    210          				}
    211          				break;
   \   0001F0   4E3C         JMP     ??eUSCI_A0_ISR_11
    212          			case '3':
    213          				if (unique_id_count == 6) {
   \                     ??eUSCI_A0_ISR_32:
   \   0001F2   B2900600.... CMP.W   #0x6, &unique_id_count
   \   0001F8   4A20         JNE     ??eUSCI_A0_ISR_11
    214          					unique_id_count = RESET_STATE;
   \   0001FA   8243....     MOV.W   #0x0, &unique_id_count
    215          					iot_command_capture = TRUE;
   \   0001FE   D243....     MOV.B   #0x1, &iot_command_capture
    216          				}
    217          				break;
   \   000202   453C         JMP     ??eUSCI_A0_ISR_11
    218          			case 0x1B:
    219          				unique_id_count++;
   \                     ??eUSCI_A0_ISR_28:
   \   000204   9253....     ADD.W   #0x1, &unique_id_count
    220          				
    221          				// do what needed for slow
    222          				break;
   \   000208   423C         JMP     ??eUSCI_A0_ISR_11
    223          			default: break;
    224          			}
    225          		}
    226          
    227          
    228          		else {
    229          			if (++iot_rx_ring_wr >= (sizeof(IOT_Char_Rx))) {
   \                     ??eUSCI_A0_ISR_26:
   \   00020A   1F42....     MOV.W   &iot_rx_ring_wr, R15
   \   00020E   1F53         ADD.W   #0x1, R15
   \   000210   824F....     MOV.W   R15, &iot_rx_ring_wr
   \   000214   3F901000     CMP.W   #0x10, R15
   \   000218   0228         JNC     ??eUSCI_A0_ISR_36
    230          				iot_rx_ring_wr = BEGINNING;
   \   00021A   8243....     MOV.W   #0x0, &iot_rx_ring_wr
    231          			}
    232          			UCA1IE |= UCTXIE;
   \                     ??eUSCI_A0_ISR_36:
   \   00021E   A2D39A05     BIS.W   #0x2, &0x59a
    233          		}
    234          
    235          		break;
   \   000222   353C         JMP     ??eUSCI_A0_ISR_11
    236          	case 4: // Vector 4 – TXIFG
    237          		
    238          		if (fram_2_iot_ready) {
   \                     ??eUSCI_A0_ISR_41:
   \   000224   8293....     CMP.W   #0x0, &fram_2_iot_ready
   \   000228   1A24         JEQ     ??eUSCI_A0_ISR_37
    239          			if (FRAM_2_IOT[fram_direct_iot] == NULL) {
   \   00022A   1F42....     MOV.W   &fram_direct_iot, R15
   \   00022E   CF93....     CMP.B   #0x0, FRAM_2_IOT(R15)
   \   000232   0720         JNE     ??eUSCI_A0_ISR_38
    240          				fram_direct_iot = RESET_STATE;
   \   000234   8243....     MOV.W   #0x0, &fram_direct_iot
    241          				fram_2_iot_ready = RESET_STATE;
   \   000238   8243....     MOV.W   #0x0, &fram_2_iot_ready
    242          				UCA0IE &= ~UCTXIE;
   \   00023C   A2C31A05     BIC.W   #0x2, &0x51a
   \   000240   263C         JMP     ??eUSCI_A0_ISR_11
    243          			}
    244          			else {
    245          				UCA0TXBUF = FRAM_2_IOT[fram_direct_iot];
   \                     ??eUSCI_A0_ISR_38:
   \   000242   1F42....     MOV.W   &fram_direct_iot, R15
   \   000246   5F4F....     MOV.B   FRAM_2_IOT(R15), R15
   \   00024A   4F4F         MOV.B   R15, R15
   \   00024C   824F0E05     MOV.W   R15, &0x50e
    246          				FRAM_2_IOT[fram_direct_iot] = NULL;
   \   000250   1F42....     MOV.W   &fram_direct_iot, R15
   \   000254   CF43....     MOV.B   #0x0, FRAM_2_IOT(R15)
    247          				fram_direct_iot++;
   \   000258   9253....     ADD.W   #0x1, &fram_direct_iot
   \   00025C   183C         JMP     ??eUSCI_A0_ISR_11
    248          			}
    249          		}
    250          		else {
    251          			UCA0TXBUF = USB_Char_Rx[usb_rx_ring_rd++];
   \                     ??eUSCI_A0_ISR_37:
   \   00025E   1F42....     MOV.W   &usb_rx_ring_rd, R15
   \   000262   0E4F         MOV.W   R15, R14
   \   000264   1E53         ADD.W   #0x1, R14
   \   000266   824E....     MOV.W   R14, &usb_rx_ring_rd
   \   00026A   5F4F....     MOV.B   USB_Char_Rx(R15), R15
   \   00026E   4F4F         MOV.B   R15, R15
   \   000270   824F0E05     MOV.W   R15, &0x50e
    252          			if (usb_rx_ring_rd >= SMALL_RING_SIZE) {
   \   000274   B2901000.... CMP.W   #0x10, &usb_rx_ring_rd
   \   00027A   0228         JNC     ??eUSCI_A0_ISR_39
    253          				usb_rx_ring_rd = BEGINNING;
   \   00027C   8243....     MOV.W   #0x0, &usb_rx_ring_rd
    254          			}
    255          			temp_2 = iot_rx_ring_wr;
   \                     ??eUSCI_A0_ISR_39:
   \   000280   1C42....     MOV.W   &iot_rx_ring_wr, R12
    256          			if (iot_rx_ring_rd == temp_2) {
   \   000284   829C....     CMP.W   R12, &iot_rx_ring_rd
   \   000288   0220         JNE     ??eUSCI_A0_ISR_11
    257          				UCA0IE &= ~UCTXIE;
   \   00028A   A2C31A05     BIC.W   #0x2, &0x51a
    258          			}
    259          		}
    260          		break;
    261          	default: break;
    262          	}
    263          }
   \                     ??eUSCI_A0_ISR_11:
   \   00028E   5A17         POPM.W  #0x6, R15
   \   000290   0013         RETI
   \   000292                REQUIRE _A_UCA0RXBUF_L
   \   000292                REQUIRE _A_UCA1IE_L
   \   000292                REQUIRE _A_UCA0IE_L
   \   000292                REQUIRE _A_UCA0TXBUF_L
   \   000292                REQUIRE _A_UCA0IV_L
    264          
    265          
    266          #pragma vector=EUSCI_A1_VECTOR

   \                                 In  segment ISR_CODE, align 2
    267          __interrupt void eUSCI_A1_ISR(void) {
   \                     eUSCI_A1_ISR:
   \   000000   3F15         PUSHM.W #0x4, R15
    268          	unsigned int temp;
    269          	unsigned int temp_2;
    270          	switch (__even_in_range(UCA1IV, 0x08)) {
   \   000002   1F429E05     MOV.W   &0x59e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for eUSCI_A1_ISR>_0`:
   \   000008   753C         JMP     ??eUSCI_A1_ISR_5
   \   00000A   033C         JMP     ??eUSCI_A1_ISR_14
   \   00000C   5B3C         JMP     ??eUSCI_A1_ISR_15
   \   00000E   723C         JMP     ??eUSCI_A1_ISR_5
   \   000010   713C         JMP     ??eUSCI_A1_ISR_5
    271          	case 0: // Vector 0 - no interrupt
    272          		break;
    273          	case 2: // Vector 2 - RXIFG
    274          		
    275          		
    276          		temp = usb_rx_ring_wr;
   \                     ??eUSCI_A1_ISR_14:
   \   000012   1D42....     MOV.W   &usb_rx_ring_wr, R13
    277          		USB_Char_Rx[temp] = UCA1RXBUF; // RX -> USB_Char_Rx character
   \   000016   1E428C05     MOV.W   &0x58c, R14
   \   00001A   CD4E....     MOV.B   R14, USB_Char_Rx(R13)
    278          	
    279          
    280          		
    281          		if (USB_Char_Rx[temp] == '^') {
   \   00001E   FD905E00.... CMP.B   #0x5e, USB_Char_Rx(R13)
   \   000024   0220         JNE     ??eUSCI_A1_ISR_6
    282          			pc_fram_command = TRUE;
   \   000026   9243....     MOV.W   #0x1, &pc_fram_command
    283          		}
    284          
    285          		if (pc_fram_command) {
   \                     ??eUSCI_A1_ISR_6:
   \   00002A   8293....     CMP.W   #0x0, &pc_fram_command
   \   00002E   3D24         JEQ     ??eUSCI_A1_ISR_7
    286          			switch (USB_Char_Rx[temp]) {
   \   000030   5E4D....     MOV.B   USB_Char_Rx(R13), R14
   \   000034   7E800D00     SUB.B   #0xd, R14
   \   000038   0A24         JEQ     ??eUSCI_A1_ISR_8
   \   00003A   7E803400     SUB.B   #0x34, R14
   \   00003E   0C24         JEQ     ??eUSCI_A1_ISR_9
   \   000040   7E800500     SUB.B   #0x5, R14
   \   000044   1624         JEQ     ??eUSCI_A1_ISR_10
   \   000046   7E800D00     SUB.B   #0xd, R14
   \   00004A   2124         JEQ     ??eUSCI_A1_ISR_11
   \   00004C   533C         JMP     ??eUSCI_A1_ISR_5
    287          			case 0x0D:
    288          				pc_fram_command = FALSE;
   \                     ??eUSCI_A1_ISR_8:
   \   00004E   8243....     MOV.W   #0x0, &pc_fram_command
    289          				// message received variable needed 
    290          				pc_fram_command_received = TRUE;
   \   000052   9243....     MOV.W   #0x1, &pc_fram_command_received
    291          				break;
   \   000056   4E3C         JMP     ??eUSCI_A1_ISR_5
    292          			case 'A':
    293          				CARROT_COMMAND[carrot_wr++] = USB_Char_Rx[temp];
   \                     ??eUSCI_A1_ISR_9:
   \   000058   1F42....     MOV.W   &carrot_wr, R15
   \   00005C   DF4D........ MOV.B   USB_Char_Rx(R13), CARROT_COMMAND(R15)
   \   000062   9253....     ADD.W   #0x1, &carrot_wr
    294          				if (carrot_wr >= sizeof(CARROT_COMMAND)) {
   \   000066   B2901000.... CMP.W   #0x10, &carrot_wr
   \   00006C   0228         JNC     ??eUSCI_A1_ISR_10
    295          					carrot_wr = RESET_STATE;
   \   00006E   8243....     MOV.W   #0x0, &carrot_wr
    296          				}
    297          			case 'F':
    298          				CARROT_COMMAND[carrot_wr++] = USB_Char_Rx[temp];
   \                     ??eUSCI_A1_ISR_10:
   \   000072   1F42....     MOV.W   &carrot_wr, R15
   \   000076   DF4D........ MOV.B   USB_Char_Rx(R13), CARROT_COMMAND(R15)
   \   00007C   9253....     ADD.W   #0x1, &carrot_wr
    299          				if (carrot_wr >= sizeof(CARROT_COMMAND)) {
   \   000080   B2901000.... CMP.W   #0x10, &carrot_wr
   \   000086   3628         JNC     ??eUSCI_A1_ISR_5
    300          					carrot_wr = RESET_STATE;
   \   000088   8243....     MOV.W   #0x0, &carrot_wr
    301          				}
    302          				// do what needed for fast
    303          				break;
   \   00008C   333C         JMP     ??eUSCI_A1_ISR_5
    304          			case 'S':
    305          				CARROT_COMMAND[carrot_wr++] = USB_Char_Rx[temp];
   \                     ??eUSCI_A1_ISR_11:
   \   00008E   1F42....     MOV.W   &carrot_wr, R15
   \   000092   DF4D........ MOV.B   USB_Char_Rx(R13), CARROT_COMMAND(R15)
   \   000098   9253....     ADD.W   #0x1, &carrot_wr
    306          				if (carrot_wr >= sizeof(CARROT_COMMAND)) {
   \   00009C   B2901000.... CMP.W   #0x10, &carrot_wr
   \   0000A2   2828         JNC     ??eUSCI_A1_ISR_5
    307          					carrot_wr = RESET_STATE;
   \   0000A4   8243....     MOV.W   #0x0, &carrot_wr
    308          				}
    309          				// do what needed for slow
    310          				break;
   \   0000A8   253C         JMP     ??eUSCI_A1_ISR_5
    311          			default: break;
    312          			}
    313          		}
    314          		else {
    315          			if (++usb_rx_ring_wr >= (sizeof(USB_Char_Rx))) {
   \                     ??eUSCI_A1_ISR_7:
   \   0000AA   1F42....     MOV.W   &usb_rx_ring_wr, R15
   \   0000AE   1F53         ADD.W   #0x1, R15
   \   0000B0   824F....     MOV.W   R15, &usb_rx_ring_wr
   \   0000B4   3F901000     CMP.W   #0x10, R15
   \   0000B8   0228         JNC     ??eUSCI_A1_ISR_12
    316          				usb_rx_ring_wr = BEGINNING;
   \   0000BA   8243....     MOV.W   #0x0, &usb_rx_ring_wr
    317          			}
    318          			UCA0IE |= UCTXIE;
   \                     ??eUSCI_A1_ISR_12:
   \   0000BE   A2D31A05     BIS.W   #0x2, &0x51a
    319          		}
    320          		
    321          		
    322          		break;
   \   0000C2   183C         JMP     ??eUSCI_A1_ISR_5
    323          	case 4: // Vector 4 – TXIFG
    324          		
    325          		UCA1TXBUF = IOT_Char_Rx[iot_rx_ring_rd++];
   \                     ??eUSCI_A1_ISR_15:
   \   0000C4   1F42....     MOV.W   &iot_rx_ring_rd, R15
   \   0000C8   0E4F         MOV.W   R15, R14
   \   0000CA   1E53         ADD.W   #0x1, R14
   \   0000CC   824E....     MOV.W   R14, &iot_rx_ring_rd
   \   0000D0   5F4F....     MOV.B   IOT_Char_Rx(R15), R15
   \   0000D4   4F4F         MOV.B   R15, R15
   \   0000D6   824F8E05     MOV.W   R15, &0x58e
    326          		if (iot_rx_ring_rd >= SMALL_RING_SIZE) {
   \   0000DA   B2901000.... CMP.W   #0x10, &iot_rx_ring_rd
   \   0000E0   0228         JNC     ??eUSCI_A1_ISR_13
    327          			iot_rx_ring_rd = BEGINNING;
   \   0000E2   8243....     MOV.W   #0x0, &iot_rx_ring_rd
    328          		}
    329          		temp_2 = iot_rx_ring_wr;
   \                     ??eUSCI_A1_ISR_13:
   \   0000E6   1C42....     MOV.W   &iot_rx_ring_wr, R12
    330          		if (iot_rx_ring_rd == temp_2) {
   \   0000EA   829C....     CMP.W   R12, &iot_rx_ring_rd
   \   0000EE   0220         JNE     ??eUSCI_A1_ISR_5
    331          			UCA1IE &= ~UCTXIE;
   \   0000F0   A2C39A05     BIC.W   #0x2, &0x59a
    332          		}
    333          		break;
    334          	default: break;
    335          	}
    336          }
   \                     ??eUSCI_A1_ISR_5:
   \   0000F4   3C17         POPM.W  #0x4, R15
   \   0000F6   0013         RETI
   \   0000F8                REQUIRE _A_UCA1RXBUF_L
   \   0000F8                REQUIRE _A_UCA0IE_L
   \   0000F8                REQUIRE _A_UCA1TXBUF_L
   \   0000F8                REQUIRE _A_UCA1IE_L
   \   0000F8                REQUIRE _A_UCA1IV_L

   \                                 In  segment INTVEC, offset 0x40, root
   \                     `??eUSCI_A1_ISR::??INTVEC 64`:
   \   000040   ....         DC16    eUSCI_A1_ISR

   \                                 In  segment INTVEC, offset 0x42, root
   \                     `??eUSCI_A0_ISR::??INTVEC 66`:
   \   000042   ....         DC16    eUSCI_A0_ISR
    337          
    338          //------------------------------------------------------------------------------

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     16   eUSCI_A0_ISR
     12   eUSCI_A1_ISR


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      16  CARROT_COMMAND
      32  FRAM_2_IOT
      50  IOT_COMMAND
      17  IP_address
       2  IP_capture
       2  IP_get
       2  IP_look
       2  IP_received
      11  SSID
       1  SSID_received
       2  S_count
       2  _A_UCA0IE_L
       2  _A_UCA0IV_L
       2  _A_UCA0RXBUF_L
       2  _A_UCA0TXBUF_L
       2  _A_UCA1IE_L
       2  _A_UCA1IV_L
       2  _A_UCA1RXBUF_L
       2  _A_UCA1TXBUF_L
       2  carrot_wr
     658  eUSCI_A0_ISR
       2  eUSCI_A0_ISR::??INTVEC 66
     248  eUSCI_A1_ISR
       2  eUSCI_A1_ISR::??INTVEC 64
       2  fram_direct_iot
       2  iot_2_pc_transmit
       1  iot_command_capture
       2  iot_command_direct
       1  iot_command_received
       2  iot_command_wr
       2  iot_fram_command
       2  iot_fram_command_received
       2  ip_wr
       2  ok_find_end
       2  ok_received
       2  pc_2_iot_transmit
       2  pc_fram_command
       2  pc_fram_command_received
       2  quote_count
       2  ssid_wr
       2  unique_id_count

 
  16 bytes in segment DATA16_AN
 171 bytes in segment DATA16_Z
   4 bytes in segment INTVEC
 906 bytes in segment ISR_CODE
 
 906 bytes of CODE  memory
   0 bytes of CONST memory (+  4 bytes shared)
 171 bytes of DATA  memory (+ 16 bytes shared)

Errors: none
Warnings: none
